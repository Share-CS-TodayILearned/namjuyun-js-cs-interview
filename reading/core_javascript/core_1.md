작성일 : 2022.04.08 (금)

# Chapter 1 : 데이터 타입

## Data Types

### 1) 기본형 (원시형, Primitive type)

1. Number
2. String
3. Boolean
4. null
5. undefined
6. Symbol

### 2) 참조형 (Reference type)

**Object**, 객체와 객체의 하위분류들

1. Array
2. Function
3. Date
4. RegExp
5. Map, WeakMap
6. Set, WeakSet

<br>

---

<br>

## 데이터 타입 관련 배경지식

### 1) 컴퓨터가 메모리와 데이터를 관리하는 방식

컴퓨터는 모든 데이터를 0, 1로 관리

→ 하나의 숫자 = 하나의 **비트(bit)**

→ 그리고 각 비트들은 고유한 식별자가 있어, 그 위치를 확인하고 불러올 수 있음

→ 하지만 고작 비트 단위로 위치를 확인하는 것은 매우 비효율적

→ 몇개의 비트들은 묶어서 하나의 단위로 만드는 것이 표현할 수 있는 값도 늘어나고 검색시간도 줄일 수 있음! <br> 하지만 동시에 너무 크게 단위를 잡으면 안쓰이고 낭비되는 비트가 생김

→ **바이트 (8비트, byte) 단위** 생겨남 : 256가지의 값을 표현할 수 있음

<br>

**정적 타입 언어 (C, C++, 자바)**<br>
메모리 낭비 최소화를 위해 데이터타입별로 할당할 메모리영역을 다르게 정해놓음<br>
ex) `정수형(short)` → 2byte → -32768 ~ 32768까지만 표현 가능<br>
그 이상의 수를 나타낼 때엔 4byte인 `정수형(int)`으로 타입 변환을 해야함

**자바스크립트**<br>
메모리 용량이 커진 상황에서 등장하여 메모리 관리 압박에서 자유로워짐, 넉넉하게 메모리 쓰자!<br>
숫자 → 정수형, 부동소수형 구분을 하지 않고 8바이트 확보

<br>

> 모든 데이터는 바이트 단위의 **식별자** = **메모리 주소값**(memory address)를 통해 서로 구분하고 연결됨

<br>

### 2) 식별자와 변수

- `변수` = 변할 수 있는 수 (variable, 수가 아니어도 됨, 변할 수 있는 무언가)
- `식별자` = 어떤 데이터를 식별하는 데 사용하는 이름 (= 변수명)

<br>

---

<br>

## 변수 선언과 데이터 할당

```jsx
var a; // 변수 선언

a = "namju"; // 변수 a에 데이터 할당

var b = "namjuyun"; // 변수 선언과 할당을 한 문장으로 씀 (일어나는 일은 동일)
```

### 1) 변수 선언

```jsx
var a; // 변수 선언
```

➡️ 변할 수 있는 데이터를 만든다, 이 데이터의 식별자는 `a`로 한다<br>
= **변경 가능한 데이터가 담길 수 있는 공간, 그릇**을 만드는 것

**실제 메모리 영역에서 일어나는 일**<br>
\- 메모리에 비어있는 공간 하나를 확보<br>
\- 그 공간의 이름(식별자)을 `a`라고 지정

<br>

### 2) 데이터 할당

```jsx
a = "abc"; // 데이터 할당
```

**실제 메모리 영역에서 일어나는 일**<br>
\- 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보<br>
\- 문자열 `'abc'`를 저장<br>
\- → 그 주소를 변수 영역에 저장함

<br>

> **변수영역에 직접 데이터를 할당하지 않는 이유**<br>
> → 데이터 변환을 자유롭게 할 수 있게 하며, 메모리를 더욱 효율적으로 관리하기 위해<br>
>
> ex) 변수영역에서 데이터 변환이 일어난다면 해당 공간의 크기를 늘리는 작업이 필요<br>
> 이 작업이 앞뒤로 다른 데이터들이 있는 상황에서 일어난다면?<br>
> → 뒤의 데이터들을 모두 옮기고 다시 식별자에 연결하는 작업이 필요해짐

<br>

### 3) 데이터 재할당

```jsx
a = a + "def"; // 'abcdef'로 재할당
```

**실제 메모리 영역에서 일어나는 일**<br>
\- 새로운 데이터를 저장하기 위한 다른 메모리 공간 확보<br>
\- 그곳에 데이터 `'abcdef'` 저장<br>
\- 새로운 메모리 주소를 `a` 변수와 연결 (기존의 데이터는 가비지 컬렉터의 대상이 됨)

<br>

> **다수의 변수들이 같은 값을 가지고 있을 때엔?**<br> > `a`, `b`, `c`, `d`, `e`, `f` 변수들 모두 `5`를 할당 했을 때엔<br>
> 5가 있는 데이터 공간이 6개 만들어지는 것이 아닌,<br>
> 한개만 만들어서 그 값을 6개의 변수 영역들이 참조한다.<br>
> ➡️ 중복 데이터 처리 효율 높아짐!

<br>

---

<br>

## 기본형 데이터, 참조형 데이터의 차이

### 1) 불변값

> **변수, 상수(constant)** <br> > **변수 영역**의 메모리가 변경 가능한지?<br>
> = 변수에 할당한 데이터 식별자가 변경될 수 있는지?

<br>

> **불변성**<br> > **데이터 영역**의 메모리가 변경 가능한지?<br>
> 이미 존재하는 데이터를 바꿀 수 있는지? 아니면 새로 데이터를 만드는지?

<br>

기본형 데이터 `Number`, `String`, `Boolean`, `null`, `undefined`, `Symbol`은 모두 **불변값**<br>
절대 한 데이터 주소 내의 값을 바꾸지 않고, 그냥 새 데이터 주소에 새 값을 만들어서 재할당한다!

```jsx
var a = "abc";
a = a + "def";
```

변수 `a`에 문자열 `'abc'`를 할당한 이후 뒤에 `'def'`를 추가 <br>
→ **기존의 `'abc'`가 바뀌는 것이 아닌**, 새로운 문자열 `'abcdef'`를 생성하고 이를 변수 `a`에 저장함

<br>

```jsx
var b = 5;
var c = 5;
b = 7;
```

변수 `b`에 할당할 숫자 `5`가 이미 메모리에 있는지 확인, 없으니까 새로 만들어서 할당<br>
변수 `c`에 할당할 숫자 `5`가 이미 있으니까 그 주소를 할당<br>
변수 `b`의 값을 `7`로 바꾸고 싶음 → **있던 `5`를 바꾸는 것이 아니라** `7`이 담긴 영역을 새로 만듦<br>
➡️ 결론, `b`는 새로만든 `7`를 저장, `c`는 원래 있던 `5`를 저장하고 있다!

<br>

> 불변값의 성질 = 한번 만들어진 값은 가비지 컬렉팅 당하지 않는 한 영원히 변하지 않는다.

<br>
<br>

### 2) 가변값

참조형 데이터는 기본적 성질은 모두 가변값 (불변값으로 만들 수 있는 방법도 있음)

```jsx
var obj1 = {
  a: 1,
  b: "bbb",
};
```

1. 빈 공간을 확보하여 그 주소의 이름을 `'obj1'`으로 정한다 _@1002_
2. 데이터를 저장하려 보니 여러 프로퍼티로 이루어진 데이터 그룹임 → 프로퍼티(key)들을 위한 별도의 변수 영역을 마련 _@7103 ~ ?_
3. 그 영역의 주소들을 한 데이터 영역에 저장 _@5001_
4. 프로퍼티 변수 영역에 key값들을 지정 → `'a'`, `'b'` _@7103, @7104_
5. 데이터 영역에 빈공간 두개를 확보해 `1`, `'bbb'`를 각각 저장 _@5003, @5004_
6. 이 데이터 주소값을 프로퍼티 변수 영역의 `'a'`, `'b'`에 할당

<br>

```jsx
obj1.a = 2;
```

**참조형 데이터가 가변적인 이유**<br>
기본적으로 데이터 영역에 저장된 값은 기본형과 똑같이 모두 불변값<br>
하지만 객체의 프로퍼티 영역이 또 있는 구조이므로, 여기에는 다른 값들이 재할당될 수 있음<br>
그러면 `obj1`가 참조하고 있는 주소값은(`@5001`)는 달라지지 않으면서 객체의 프로퍼티는 다른 값을 가지게 됨!<br>
➡️ **가변성**!!

<br>
이때 obj1의 값을 바꿔준다면?

```jsx
obj1 = "string";
```

새로운 데이터 `'string'`을 만들어 `'obj1'`은 그 주소값을 다시 저장<br>
➡️ 아무에게도 참조되지 않는 주소값이 생겨버림 (객체 프로퍼티의 변수 영역을 담고있는 데이터, 프로퍼티 영역의 변수들, 프로퍼티 변수들에 할당된 데이터값들)<br>
➡️ `참조 카운트`가 0이 된 메모리 주소는 순차적으로 가비지 컬렉터가 수거한다

<br>
<br>

## 변수 복사 비교

### 기본형

```jsx
var a = 10;
var b = a;
```

1. 빈 공간에 변수 `a`를 지정
2. 숫자 `10`이 데이터에 있는지 확인하고 없으면 빈 공간에 저장
3. 해당 데이터를 변수 `a`에 저장
4. 복사 : 빈 공간에 변수 `b`를 지정하고 식별자 `a`를 검색해 값을 찾아와서 `b`에 저장<br>
   ➡️ 지금은 a와 b가 같은 데이터를 참조하고 있음

```jsx
a = 20;
```

1. 숫자 `20`이 데이터에 있는지 확인하고, 없으니까 빈 공간에 저장
2. 해당 데이터를 변수 `a`에 다시 할당<br>
   ➡️ a와 b가 다른 데이터를 참조하고 있음! 이전의 `10` 주소값은 여전히 있고, `b`에 의해 참조되고 있음! 깔끔하게 복사완료!

<br>

### 참조형

```jsx
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

1. 빈 공간에 변수 `obj1`를 지정
2. 데이터 그룹이니 프로퍼티들을 지정할 별도의 주소들 만듦
3. 이 주소들을 담고 있는 데이터 생성 → `obj1`에 할당
4. 프로퍼티 영역에 `c`, `d` 변수 지정
5. 데이터 영역에 `10`, `'ddd'` 저장 → 각각 변수들에 할당
6. 복사 : 빈 공간에 변수 `obj2`를 지정하고 식별자 `obj1`가 참조하는 데이터를 저장<br>
   ➡️ 지금은 obj1, obj2가 모두 같은 데이터를 참조하고 있음

<br>

```jsx
obj1.c = 20;

console.log(obj1); // { c: 20, d: "ddd" }
console.log(obj2); // { c: 20, d: "ddd" }
```

1. 숫자 `20`이 데이터에 없으니 새로 만들고, 이를 프로퍼티 `c`에 저장함
2. 그러면 지금 obj1과 obj2가 참조하고 있는 값에는 전혀 변화가 없음 (가변성)<br>
   ➡️ obj1, obj2는 같은 데이터를 아직도 참조하고 있고, **obj1만 바꿨는데 obj2도 바뀌게 되어버림!**

<br>

```jsx
obj2 = { c: "hi", d: "everyone" };

console.log(obj1); // { c: 20, d: "ddd" }
console.log(obj2); // { c: "hi", d: "everyone" }
```

하지만 이렇게 새로운 객체를 할당해버리면, 아예 새로운 객체 영역이 생성되고, 새로운 참조값이 생김<br>
➡️ **기본형 데이터와 같은 방식**으로 재할당이 일어나게 됨!

<br>

> '가변'은 참조형 데이터 자체를 변경할 경우가 아닌, 그 내부의 프로퍼티를 변경할 때만 성립
